// Copyright 2020-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package fastpb

// Code generated by internal/stencil. DO NOT EDIT

import (
	"github.com/bufbuild/fastpb/internal/swiss"
	"github.com/bufbuild/fastpb/internal/unsafe2"
	"google.golang.org/protobuf/encoding/protowire"
)

func parseScalarMapV32xV32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint32], varintItem[uint32], uint32, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint32]
	var vi varintItem[uint32]
	var k uint32
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV32xV64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint32], varintItem[uint64], uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint32]
	var vi varintItem[uint64]
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV32xZ32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint32], zigzagItem[uint32], uint32, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint32]
	var vi zigzagItem[uint32]
	var k uint32
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV32xZ64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint32], zigzagItem[uint64], uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint32]
	var vi zigzagItem[uint64]
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV32xF32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint32], fixed32Item, uint32, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint32]
	var vi fixed32Item
	var k uint32
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV32xF64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint32], fixed64Item, uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint32]
	var vi fixed64Item
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV32xV1(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint32], boolItem, uint32, uint8]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint32]
	var vi boolItem
	var k uint32
	var v uint8

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint8]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint8]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint8](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint8]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU8(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU8(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint8](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint8]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU8(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU8(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV32xS(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint32], stringItem, uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint32]
	var vi stringItem
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV32xB(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint32], bytesItem, uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint32]
	var vi bytesItem
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV64xV32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint64], varintItem[uint32], uint64, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint64]
	var vi varintItem[uint32]
	var k uint64
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV64xV64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint64], varintItem[uint64], uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint64]
	var vi varintItem[uint64]
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV64xZ32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint64], zigzagItem[uint32], uint64, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint64]
	var vi zigzagItem[uint32]
	var k uint64
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV64xZ64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint64], zigzagItem[uint64], uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint64]
	var vi zigzagItem[uint64]
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV64xF32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint64], fixed32Item, uint64, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint64]
	var vi fixed32Item
	var k uint64
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV64xF64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint64], fixed64Item, uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint64]
	var vi fixed64Item
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV64xV1(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint64], boolItem, uint64, uint8]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint64]
	var vi boolItem
	var k uint64
	var v uint8

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint8]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint8]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint8](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint8]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU8(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU8(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint8](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint8]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU8(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU8(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV64xS(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint64], stringItem, uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint64]
	var vi stringItem
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapV64xB(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[varintItem[uint64], bytesItem, uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki varintItem[uint64]
	var vi bytesItem
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ32xV32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint32], varintItem[uint32], uint32, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint32]
	var vi varintItem[uint32]
	var k uint32
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ32xV64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint32], varintItem[uint64], uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint32]
	var vi varintItem[uint64]
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ32xZ32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint32], zigzagItem[uint32], uint32, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint32]
	var vi zigzagItem[uint32]
	var k uint32
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ32xZ64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint32], zigzagItem[uint64], uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint32]
	var vi zigzagItem[uint64]
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ32xF32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint32], fixed32Item, uint32, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint32]
	var vi fixed32Item
	var k uint32
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ32xF64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint32], fixed64Item, uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint32]
	var vi fixed64Item
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ32xV1(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint32], boolItem, uint32, uint8]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint32]
	var vi boolItem
	var k uint32
	var v uint8

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint8]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint8]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint8](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint8]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU8(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU8(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint8](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint8]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU8(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU8(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ32xS(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint32], stringItem, uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint32]
	var vi stringItem
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ32xB(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint32], bytesItem, uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint32]
	var vi bytesItem
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ64xV32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint64], varintItem[uint32], uint64, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint64]
	var vi varintItem[uint32]
	var k uint64
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ64xV64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint64], varintItem[uint64], uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint64]
	var vi varintItem[uint64]
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ64xZ32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint64], zigzagItem[uint32], uint64, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint64]
	var vi zigzagItem[uint32]
	var k uint64
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ64xZ64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint64], zigzagItem[uint64], uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint64]
	var vi zigzagItem[uint64]
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ64xF32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint64], fixed32Item, uint64, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint64]
	var vi fixed32Item
	var k uint64
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ64xF64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint64], fixed64Item, uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint64]
	var vi fixed64Item
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ64xV1(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint64], boolItem, uint64, uint8]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint64]
	var vi boolItem
	var k uint64
	var v uint8

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint8]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint8]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint8](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint8]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU8(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU8(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint8](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint8]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU8(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU8(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ64xS(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint64], stringItem, uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint64]
	var vi stringItem
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapZ64xB(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[zigzagItem[uint64], bytesItem, uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki zigzagItem[uint64]
	var vi bytesItem
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF32xV32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed32Item, varintItem[uint32], uint32, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed32Item
	var vi varintItem[uint32]
	var k uint32
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF32xV64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed32Item, varintItem[uint64], uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed32Item
	var vi varintItem[uint64]
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF32xZ32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed32Item, zigzagItem[uint32], uint32, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed32Item
	var vi zigzagItem[uint32]
	var k uint32
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF32xZ64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed32Item, zigzagItem[uint64], uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed32Item
	var vi zigzagItem[uint64]
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF32xF32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed32Item, fixed32Item, uint32, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed32Item
	var vi fixed32Item
	var k uint32
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF32xF64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed32Item, fixed64Item, uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed32Item
	var vi fixed64Item
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF32xV1(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed32Item, boolItem, uint32, uint8]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed32Item
	var vi boolItem
	var k uint32
	var v uint8

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint8]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint8]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint8](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint8]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU8(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU8(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint8](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint8]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU8(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU8(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF32xS(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed32Item, stringItem, uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed32Item
	var vi stringItem
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF32xB(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed32Item, bytesItem, uint32, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed32Item
	var vi bytesItem
	var k uint32
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint32, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint32, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint32, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU32xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU32xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint32, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint32, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU32xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU32xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF64xV32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed64Item, varintItem[uint32], uint64, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed64Item
	var vi varintItem[uint32]
	var k uint64
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF64xV64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed64Item, varintItem[uint64], uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed64Item
	var vi varintItem[uint64]
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF64xZ32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed64Item, zigzagItem[uint32], uint64, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed64Item
	var vi zigzagItem[uint32]
	var k uint64
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF64xZ64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed64Item, zigzagItem[uint64], uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed64Item
	var vi zigzagItem[uint64]
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF64xF32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed64Item, fixed32Item, uint64, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed64Item
	var vi fixed32Item
	var k uint64
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF64xF64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed64Item, fixed64Item, uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed64Item
	var vi fixed64Item
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF64xV1(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed64Item, boolItem, uint64, uint8]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed64Item
	var vi boolItem
	var k uint64
	var v uint8

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint8]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint8]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint8](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint8]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU8(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU8(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint8](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint8]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU8(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU8(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF64xS(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed64Item, stringItem, uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed64Item
	var vi stringItem
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapF64xB(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[fixed64Item, bytesItem, uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki fixed64Item
	var vi bytesItem
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapSxV32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[stringItem, varintItem[uint32], uint64, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki stringItem
	var vi varintItem[uint32]
	var k uint64
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapSxV64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[stringItem, varintItem[uint64], uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki stringItem
	var vi varintItem[uint64]
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapSxZ32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[stringItem, zigzagItem[uint32], uint64, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki stringItem
	var vi zigzagItem[uint32]
	var k uint64
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapSxZ64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[stringItem, zigzagItem[uint64], uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki stringItem
	var vi zigzagItem[uint64]
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapSxF32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[stringItem, fixed32Item, uint64, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki stringItem
	var vi fixed32Item
	var k uint64
	var v uint32

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint32]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint32]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint32](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU32(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU32(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint32](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint32]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU32(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU32(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapSxF64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[stringItem, fixed64Item, uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki stringItem
	var vi fixed64Item
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapSxV1(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[stringItem, boolItem, uint64, uint8]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki stringItem
	var vi boolItem
	var k uint64
	var v uint8

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint8]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint8]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint8](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint8]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU8(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU8(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint8](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint8]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU8(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU8(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapSxS(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[stringItem, stringItem, uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki stringItem
	var vi stringItem
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseScalarMapSxB(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseScalarMap[stringItem, bytesItem, uint64, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var ki stringItem
	var vi bytesItem
	var k uint64
	var v uint64

	kTag := protowire.EncodeTag(1, ki.kind())
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		p1, p2, k = ki.parse(p1, p2)
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			p1, p2, k = ki.parse(p1, p2)
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	extract := ki.extract(p1, p2)
	var mp **swiss.Table[uint64, uint64]
	p1, p2, mp = getMutableField[*swiss.Table[uint64, uint64]](p1, p2)

	m := *mp
	if m == nil {
		size, _ := swiss.Layout[uint64, uint64](1)
		m = unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m)
		swiss.InitU64xU64(m, 1, nil, extract)
	}

	vp := swiss.InsertU64xU64(m, k, extract)
	if vp == nil {
		size, _ := swiss.Layout[uint64, uint64](m.Len() + 1)
		m2 := unsafe2.Cast[swiss.Table[uint64, uint64]](p1.arena().Alloc(size))
		unsafe2.StoreNoWB(mp, m2)
		swiss.InitU64xU64(m2, m.Len()+1, m, extract)
		vp = swiss.InsertU64xU64(m2, k, extract)
	}

	*vp = v

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseBoolScalarMapV32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseBoolScalarMap[varintItem[uint32], uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var p *uint32
	p1, p2, p = getMutableField[uint32](p1, p2)

	var k bool
	var vi varintItem[uint32]
	var v uint32

	kTag := protowire.EncodeTag(1, protowire.VarintType)
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		var n uint64
		p1, p2, n = p1.varint(p2)
		k = n != 0
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			var n uint64
			p1, p2, n = p1.varint(p2)
			k = n != 0
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	var idx uint32
	if k {
		idx = 1
	}

	*unsafe2.Add(p, idx) = v
	p2.m().setBit(p2.f().offset.bit+idx, true)

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseBoolScalarMapV64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseBoolScalarMap[varintItem[uint64], uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var p *uint64
	p1, p2, p = getMutableField[uint64](p1, p2)

	var k bool
	var vi varintItem[uint64]
	var v uint64

	kTag := protowire.EncodeTag(1, protowire.VarintType)
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		var n uint64
		p1, p2, n = p1.varint(p2)
		k = n != 0
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			var n uint64
			p1, p2, n = p1.varint(p2)
			k = n != 0
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	var idx uint32
	if k {
		idx = 1
	}

	*unsafe2.Add(p, idx) = v
	p2.m().setBit(p2.f().offset.bit+idx, true)

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseBoolScalarMapZ32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseBoolScalarMap[zigzagItem[uint32], uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var p *uint32
	p1, p2, p = getMutableField[uint32](p1, p2)

	var k bool
	var vi zigzagItem[uint32]
	var v uint32

	kTag := protowire.EncodeTag(1, protowire.VarintType)
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		var n uint64
		p1, p2, n = p1.varint(p2)
		k = n != 0
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			var n uint64
			p1, p2, n = p1.varint(p2)
			k = n != 0
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	var idx uint32
	if k {
		idx = 1
	}

	*unsafe2.Add(p, idx) = v
	p2.m().setBit(p2.f().offset.bit+idx, true)

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseBoolScalarMapZ64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseBoolScalarMap[zigzagItem[uint64], uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var p *uint64
	p1, p2, p = getMutableField[uint64](p1, p2)

	var k bool
	var vi zigzagItem[uint64]
	var v uint64

	kTag := protowire.EncodeTag(1, protowire.VarintType)
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		var n uint64
		p1, p2, n = p1.varint(p2)
		k = n != 0
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			var n uint64
			p1, p2, n = p1.varint(p2)
			k = n != 0
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	var idx uint32
	if k {
		idx = 1
	}

	*unsafe2.Add(p, idx) = v
	p2.m().setBit(p2.f().offset.bit+idx, true)

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseBoolScalarMapF32(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseBoolScalarMap[fixed32Item, uint32]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var p *uint32
	p1, p2, p = getMutableField[uint32](p1, p2)

	var k bool
	var vi fixed32Item
	var v uint32

	kTag := protowire.EncodeTag(1, protowire.VarintType)
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		var n uint64
		p1, p2, n = p1.varint(p2)
		k = n != 0
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			var n uint64
			p1, p2, n = p1.varint(p2)
			k = n != 0
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	var idx uint32
	if k {
		idx = 1
	}

	*unsafe2.Add(p, idx) = v
	p2.m().setBit(p2.f().offset.bit+idx, true)

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseBoolScalarMapF64(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseBoolScalarMap[fixed64Item, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var p *uint64
	p1, p2, p = getMutableField[uint64](p1, p2)

	var k bool
	var vi fixed64Item
	var v uint64

	kTag := protowire.EncodeTag(1, protowire.VarintType)
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		var n uint64
		p1, p2, n = p1.varint(p2)
		k = n != 0
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			var n uint64
			p1, p2, n = p1.varint(p2)
			k = n != 0
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	var idx uint32
	if k {
		idx = 1
	}

	*unsafe2.Add(p, idx) = v
	p2.m().setBit(p2.f().offset.bit+idx, true)

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseBoolScalarMapV1(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseBoolScalarMap[boolItem, uint8]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var p *uint8
	p1, p2, p = getMutableField[uint8](p1, p2)

	var k bool
	var vi boolItem
	var v uint8

	kTag := protowire.EncodeTag(1, protowire.VarintType)
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		var n uint64
		p1, p2, n = p1.varint(p2)
		k = n != 0
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			var n uint64
			p1, p2, n = p1.varint(p2)
			k = n != 0
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	var idx uint32
	if k {
		idx = 1
	}

	*unsafe2.Add(p, idx) = v
	p2.m().setBit(p2.f().offset.bit+idx, true)

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseBoolScalarMapS(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseBoolScalarMap[stringItem, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var p *uint64
	p1, p2, p = getMutableField[uint64](p1, p2)

	var k bool
	var vi stringItem
	var v uint64

	kTag := protowire.EncodeTag(1, protowire.VarintType)
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		var n uint64
		p1, p2, n = p1.varint(p2)
		k = n != 0
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			var n uint64
			p1, p2, n = p1.varint(p2)
			k = n != 0
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	var idx uint32
	if k {
		idx = 1
	}

	*unsafe2.Add(p, idx) = v
	p2.m().setBit(p2.f().offset.bit+idx, true)

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}

func parseBoolScalarMapB(p1 parser1, p2 parser2) (parser1, parser2) {
	_ = parseBoolScalarMap[bytesItem, uint64]

	var n uint32
	p1, p2, n = p1.lengthPrefix(p2)

	p2.scratch = uint64(p1.e_)
	p1.e_ = p1.b_.Add(int(n))

	var p *uint64
	p1, p2, p = getMutableField[uint64](p1, p2)

	var k bool
	var vi bytesItem
	var v uint64

	kTag := protowire.EncodeTag(1, protowire.VarintType)
	vTag := protowire.EncodeTag(2, vi.kind())

	p1.log(p2, "first byte", "%#02x", *p1.b())
	if *p1.b() == byte(kTag) {
		p1.b_++
		var n uint64
		p1, p2, n = p1.varint(p2)
		k = n != 0
		p1.log(p2, "second byte", "%#02x", *p1.b())
		if *p1.b() == byte(vTag) {
			p1.b_++
			p1, p2, v = vi.parse(p1, p2)
			p1.log(p2, "map done?",
				"%v:%v, %v/%x: %v/%x",
				p1.b_, p1.e_,
				k, unsafe2.Bytes(&k),
				v, unsafe2.Bytes(&v))
			if p1.b_ == p1.e_ {
				goto insert
			}
		}
	}

	for p1.b_ < p1.e_ {
		var tag uint64
		p1, p2, tag = p1.varint(p2)
		switch tag {
		case kTag:
			var n uint64
			p1, p2, n = p1.varint(p2)
			k = n != 0
		case vTag:
			p1, p2, v = vi.parse(p1, p2)
		default:
			n, t := protowire.DecodeTag(tag)
			m := protowire.ConsumeFieldValue(n, t, p1.buf())
			p1.b_ = p1.b_.Add(m)
		}
	}

insert:
	var idx uint32
	if k {
		idx = 1
	}

	*unsafe2.Add(p, idx) = v
	p2.m().setBit(p2.f().offset.bit+idx, true)

	p1.e_ = unsafe2.Addr[byte](p2.scratch)
	return p1, p2
}
